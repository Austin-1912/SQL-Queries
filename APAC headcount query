CREATE OR REPLACE TABLE CAR_825_TXN_BASE AS
SELECT
    SNDCUSTOMER_KEY,
    RCVCUSTOMER_KEY,
    TXN_ID,
    SNDCOUNTRY_CODE AS snd_country,
    RCVCOUNTRY_CODE AS rcv_country,
    PAYOUT_TYPE,
    SNDPRINCIPAL_USD,
    RCVPAYING_DATETIME AS txn_dt,
    PRIMARY_CHANNEL,
    REVENUE,
    YEAR(RCVPAYING_DATETIME) AS txn_year,
    -- PPT Bucket
    CASE
        WHEN SNDPRINCIPAL_USD < 100 THEN 'A.<$100'
        WHEN SNDPRINCIPAL_USD >= 100 AND SNDPRINCIPAL_USD < 500 THEN 'B.$100-$500'
        WHEN SNDPRINCIPAL_USD >= 500 AND SNDPRINCIPAL_USD < 1000 THEN 'C.$500-$1,000'
        WHEN SNDPRINCIPAL_USD >= 1000 AND SNDPRINCIPAL_USD < 2000 THEN 'D.$1,000-$2,000'
        WHEN SNDPRINCIPAL_USD >= 2000 AND SNDPRINCIPAL_USD < 5000 THEN 'E.$2,000-$5,000'
        WHEN SNDPRINCIPAL_USD >= 5000 THEN 'F.$5,000+'
        ELSE 'Unknown'
    END AS PPT_bucket
FROM WUDNA.SUMMARY_GEN.WUDNA_TXN_MASTER_VW
WHERE
    DATE(RCVPAYING_DATETIME) >= '2021-01-01' AND DATE(RCVPAYING_DATETIME) <= '2025-12-31' AND 
    SUB_CHANNEL IN ('DIGITAL PARTNERS DWL')
    AND VALID_TXN_TYPE_CODE = 'Y'
    AND SNDPRINCIPAL_USD > 0
    AND REFUND_TRXN = 'N'
    AND PRODUCT_GROUP NOT IN ('QCOL', 'QCSH')
    AND send_super_region = 'MEPA' AND SNDCUSTOMER_KEY IS NOT NULL;

select txn_year, count(distinct TXN_ID) from CAR_825_TXN_BASE group by 1; 
 
-- Step 2: Create dominant corridor table per sender customer
CREATE OR REPLACE TABLE CAR_825_DOMINANT_CORRIDOR AS
SELECT *
FROM (
    SELECT
        SNDCUSTOMER_KEY,
        CONCAT(snd_country, '-', rcv_country) AS corridor,
        snd_country,
        rcv_country,
        COUNT(DISTINCT TXN_ID) AS txn_count,
        SUM(SNDPRINCIPAL_USD) AS total_principal_usd,
        ROW_NUMBER() OVER (
            PARTITION BY SNDCUSTOMER_KEY
            ORDER BY COUNT(DISTINCT TXN_ID) DESC, MAX(txn_dt) DESC
        ) AS rnk
    FROM CAR_825_TXN_BASE
    GROUP BY SNDCUSTOMER_KEY, snd_country, rcv_country
)
WHERE rnk = 1;
 
-- Step 3: Create dominant payout type table per sender customer
CREATE OR REPLACE TABLE CAR_825_DOMINANT_PAYOUT AS
SELECT *
FROM (
    SELECT
        SNDCUSTOMER_KEY,
        PAYOUT_TYPE,
        COUNT(DISTINCT TXN_ID) AS txn_count,
        SUM(SNDPRINCIPAL_USD) AS total_principal_usd,
        ROW_NUMBER() OVER (
            PARTITION BY SNDCUSTOMER_KEY
            ORDER BY COUNT(DISTINCT TXN_ID) DESC, MAX(txn_dt) DESC
        ) AS rnk
    FROM CAR_825_TXN_BASE
    GROUP BY SNDCUSTOMER_KEY, PAYOUT_TYPE
)
WHERE rnk = 1;


-- Step 3b: Dominant PPT bucket per customer for 2025
CREATE OR REPLACE TABLE CAR_825_DOMINANT_PPT_BUCKET_2025 AS
SELECT *
FROM (
    SELECT
        SNDCUSTOMER_KEY,
        PPT_bucket,
        COUNT(DISTINCT TXN_ID) AS txn_count,
        SUM(SNDPRINCIPAL_USD) AS total_principal_usd,
        ROW_NUMBER() OVER (
            PARTITION BY SNDCUSTOMER_KEY
            ORDER BY COUNT(DISTINCT TXN_ID) DESC, MAX(txn_dt) DESC
        ) AS rnk
    FROM CAR_825_TXN_BASE
    GROUP BY SNDCUSTOMER_KEY, PPT_bucket
)
WHERE rnk = 1;

 
-- Step 4: Create customer activity by year for segmentation
CREATE OR REPLACE TABLE CAR_825_CUSTOMER_YEAR_ACTIVITY AS
SELECT
    SNDCUSTOMER_KEY,
    MAX(CASE WHEN txn_year = 2025 THEN 1 ELSE 0 END) AS has_2025_txn,
    MAX(CASE WHEN txn_year = 2024 THEN 1 ELSE 0 END) AS has_2024_txn,
    MAX(CASE WHEN txn_year < 2024 THEN 1 ELSE 0 END) AS has_pre2024_txn
FROM CAR_825_TXN_BASE
GROUP BY SNDCUSTOMER_KEY;
 
-- Step 5: Create comprehensive customer summary with all attributes
CREATE OR REPLACE TABLE CAR_825_CUSTOMER_SUMMARY AS
SELECT
    b.SNDCUSTOMER_KEY,
    COUNT(DISTINCT b.TXN_ID) AS total_transactions,
    SUM(b.SNDPRINCIPAL_USD) AS total_principal_usd,
    SUM(b.REVENUE) AS total_revenue,
    
    -- Dominant corridor info
    c.corridor AS dominant_corridor,
   c.snd_country AS dominant_snd_country,
 c.rcv_country AS dominant_rcv_country,
    
    -- Dominant payout info
    p.PAYOUT_TYPE AS dominant_payout_type,
    
    -- Customer Segmentation Flag
    CASE
        WHEN y.has_2025_txn = 1 AND y.has_2024_txn = 0 AND y.has_pre2024_txn = 0 THEN 'New'
        WHEN y.has_2025_txn = 1 AND y.has_2024_txn = 1 THEN 'Existing'
        WHEN y.has_2025_txn = 1 AND y.has_2024_txn = 0 AND y.has_pre2024_txn = 1 THEN 'Winback'
        ELSE 'Other'
    END AS customer_segment,
    
    dppt.PPT_bucket AS dominant_ppt_bucket_2025
 
 
FROM CAR_825_TXN_BASE b
LEFT JOIN CAR_825_DOMINANT_CORRIDOR c
    ON b.SNDCUSTOMER_KEY = c.SNDCUSTOMER_KEY
LEFT JOIN CAR_825_DOMINANT_PAYOUT p
    ON b.SNDCUSTOMER_KEY = p.SNDCUSTOMER_KEY
LEFT JOIN CAR_825_CUSTOMER_YEAR_ACTIVITY y
    ON b.SNDCUSTOMER_KEY = y.SNDCUSTOMER_KEY
LEFT JOIN CAR_825_DOMINANT_PPT_BUCKET_2025 dppt
    ON b.SNDCUSTOMER_KEY = dppt.SNDCUSTOMER_KEY

    WHERE y.has_2025_txn = 1
GROUP BY
   ALL;

--Pull Final Data 1
 select dominant_corridor, dominant_payout_type, dominant_ppt_bucket_2025, customer_segment, count(distinct sndcustomer_key) as CX from CAR_825_CUSTOMER_SUMMARY GROUP BY ALL;
 
    

-- Step 7: Summary statistics for TPC by customer segment
CREATE OR REPLACE TABLE CAR_825_CUSTOMER_SUMMARY_TPC AS
SELECT
    customer_segment,

    /* Bucket based on each customer's total transactions */
    CASE
        WHEN total_transactions = 1 THEN 'A.1x'
        WHEN total_transactions = 2 THEN 'B.2x'
        WHEN total_transactions = 3 THEN 'C.3x'
        WHEN total_transactions >= 4 THEN 'D.4x+'
        ELSE 'E.Unknown'
    END AS TPC_bucket,

    /* Number of customers in this segment/bucket */
    COUNT(DISTINCT SNDCUSTOMER_KEY) AS customer_count,

    /* Optional QA metrics */
    SUM(total_transactions) AS group_total_transactions,
    SUM(total_principal_usd) AS group_total_principal_usd
FROM CAR_825_CUSTOMER_SUMMARY
GROUP BY
    ALL;
--Pull Final Data 2
select * from CAR_825_CUSTOMER_SUMMARY_TPC; 
i now want to do this for quarterly where with respect to the Q4 data, the way I would like to see it is Dec 25 end what is the win back, new, existing(all metrics like PPT, TPC, dominant corridor and payout should be there) 90 days, 180 days, 270 days, 360 days. Write the script for it. Keep is simple
